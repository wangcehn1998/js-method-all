<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body></body>
  <!-- Object.assign() -->
  <script>
    //   Object.assign() 用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。
    // 参数 target目标对象。 sources源对象。返回值目标对象。
    // 如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性。
    const target = { a: 1, b: 2 };
    const source = { b: 4, c: 5 };
    const returnedTarget = Object.assign(target, source);
    console.log(target); //{ a: 1, b: 4, c: 5 }
    console.log(returnedTarget); //{ a: 1, b: 4, c: 5 }
  </script>
  <!-- Object.create() -->
  <script>
    // Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。
    // 参数：proto新创建对象的原型对象。
    var me = Object.create(person);
    me.name = "a";
  </script>
  <!-- Object.defineProperties()  -->
  <script>
    // Object.defineProperties(obj, props) 方法直接在一个对象上定义新的属性或修改现有属性，并返回该对象。
    var obj = {};
    Object.defineProperties(obj, {
      property1: {
        value: true,
        writable: true,
      },
      property2: {
        value: "Hello",
        writable: false,
      },
      // etc. etc.
    });
    console.log(obj);
  </script>
  <!--Object.entries() -->
  <script>
    // Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组，
    // 其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环还会枚举原型链中的属性）。
  </script>
  <!--Object.fromEntries() -->
  <script>
    // Object.fromEntries() 方法把键值对列表转换为一个对象。
    const entries = new Map([
      ["foo", "bar"],
      ["baz", 42],
    ]);

    const obj = Object.fromEntries(entries);

    console.log(obj);
    // expected output: Object { foo: "bar", baz: 42 }
  </script>
  <!--Object.getOwnPropertyNames() -->
  <script>
    // Object.getOwnPropertyNames()方法返回一个由指定对象的所有自身属性的属性名
    // （包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。
    // 参数obj一个对象，其自身的可枚举和不可枚举属性的名称被返回。
    // 返回值在给定对象上找到的自身属性对应的字符串数组。
    var arr = ["a", "b", "c"];
    console.log(Object.getOwnPropertyNames(arr).sort()); // ["0", "1", "2", "length"]
  </script>
  <!-- Object.getPrototypeOf() -->
  <script>
    //   Object.getPrototypeOf() 方法返回指定对象的原型（内部[[Prototype]]属性的值）。
    //   Object.getPrototypeOf(object)
    // 参数obj要返回其原型的对象。
    // 返回值给定对象的原型。如果没有继承属性，则返回 null 。
    const prototype1 = {};
    const object1 = Object.create(prototype1);
    console.log(Object.getPrototypeOf(object1) === prototype1);
    // expected output: true
  </script>
  <!-- Object.is() -->
  <script>
    //   Object.is() 方法判断两个值是否为同一个值。
    // Object.is(value1, value2);
    // 参数value1被比较的第一个值。 value2被比较的第二个值。 返回值一个 Boolean 类型标示两个参数是否是同一个值。
  </script>
  <!-- Object.keys()  -->
  <script>
    //   Object.keys() 会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 。
    // Object.keys(obj)
    // 参数obj要返回其枚举自身属性的对象。 返回值一个表示给定对象的所有可枚举属性的字符串数组。
    // simple array
    var arr = ["a", "b", "c"];
    console.log(Object.keys(arr)); // console: ['0', '1', '2']

    // array like object
    var obj = { 0: "a", 1: "b", 2: "c" };
    console.log(Object.keys(obj)); // console: ['0', '1', '2']

    // array like object with random key ordering
    var anObj = { 100: "a", 2: "b", 7: "c" };
    console.log(Object.keys(anObj)); // console: ['2', '7', '100']

    // getFoo is a property which isn't enumerable
    var myObj = Object.create(
      {},
      {
        getFoo: {
          value: function () {
            return this.foo;
          },
        },
      }
    );
    myObj.foo = 1;
    console.log(Object.keys(myObj)); // console: ['foo']
  </script>
  <!-- hasOwnProperty() -->
  <script>
    // Object.hasOwnProperty() 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是，是否有指定的键）。
    const object1 = {};

    object1.property1 = 42;
    console.log(object1.hasOwnProperty("property1"));
    // expected output: true

    console.log(object1.hasOwnProperty("toString"));
    // expected output: false

    console.log(object1.hasOwnProperty("hasOwnProperty"));
    // expected output: false
  </script>
</html>
